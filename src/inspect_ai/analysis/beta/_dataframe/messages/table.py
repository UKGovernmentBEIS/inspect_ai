from __future__ import annotations

from typing import TYPE_CHECKING, Callable, Literal, TypeAlias

from inspect_ai.model._chat_message import ChatMessage

if TYPE_CHECKING:
    import pandas as pd

from typing_extensions import overload

from ..columns import Column, ColumnErrors
from ..samples.table import MessagesDetail, _read_samples_df
from ..util import LogPaths, verify_prerequisites
from .columns import MessageColumns

MessageFilter: TypeAlias = (
    list[Literal["system", "user", "assistant", "tool"]] | Callable[[ChatMessage], bool]
)
"""Filter for `messages_df()` rows."""


@overload
def messages_df(
    logs: LogPaths,
    columns: list[Column] = MessageColumns,
    source: Literal["task_state", "transcript"] = "task_state",
    filter: MessageFilter | None = None,
    recursive: bool = True,
    strict: Literal[True] = True,
) -> "pd.DataFrame": ...


@overload
def messages_df(
    logs: LogPaths,
    columns: list[Column] = MessageColumns,
    source: Literal["task_state", "transcript"] = "task_state",
    filter: MessageFilter | None = None,
    recursive: bool = True,
    strict: Literal[False] = False,
) -> tuple["pd.DataFrame", ColumnErrors]: ...


def messages_df(
    logs: LogPaths,
    columns: list[Column] = MessageColumns,
    source: Literal["task_state", "transcript"] = "task_state",
    filter: MessageFilter | None = None,
    recursive: bool = True,
    strict: bool = True,
) -> "pd.DataFrame" | tuple["pd.DataFrame", ColumnErrors]:
    """Read a dataframe containing messages from a set of evals.

    Args:
       logs: One or more paths to log files or log directories.
       columns: Specification for what columns to read from log files.
       source: Source to draw messages from. "task_state" (the default) takes them
          from the `messages` property of `TaskState`; "transcript" takes them
          from the transcript, which will include all messages including those
          generated by helper models, scoring, etc. Note that "transcript" messages
          are filtered for uniqueness so that messages don't repeat.
       filter: List of message role types to include or callable that performs the filter.
       recursive: Include recursive contents of directories (defaults to `True`)
       strict: Raise import errors immediately. Defaults to `True`.
          If `False` then a tuple of `DataFrame` and errors is returned.

    Returns:
       For `strict`, a Pandas `DataFrame` with information for the specified logs.
       For `strict=False`, a tuple of Pandas `DataFrame` and a dictionary of errors
       encountered (by log file) during import.
    """
    verify_prerequisites()

    # resolve filter/detail
    if filter is None:
        detail = MessagesDetail(source=source, filter=lambda m: True)
    elif callable(filter):
        detail = MessagesDetail(source=source, filter=filter)
    else:
        detail = MessagesDetail(source=source, filter=lambda m: m.role in filter)

    return _read_samples_df(
        logs=logs,
        columns=columns,
        recursive=recursive,
        strict=strict,
        detail=detail,
    )
