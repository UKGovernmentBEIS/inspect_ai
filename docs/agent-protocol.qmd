---
title: Agent Protocol (Beta)
---

## Overview

::: {.callout-note}
The Inspect agent protocol described below is available only in the development version of Inspect. To install the development version from GitHub:

``` bash
pip install git+https://github.com/UKGovernmentBEIS/inspect_ai
```
:::


The Inspect `Agent` protocol enables you to create flexible agent components that can be used in a wide variety of contexts. Agents are similar to solvers, but use a narrower interface that makes them considerably more versatile. A single agent can be:

1.  Used as a top-level `Solver` for a task
2.  Provided as a standard `Tool` to a model
3.  Delegated to in a multi-agent architecture.
4.  Run as a standalone operation in an agent workflow.

The agents module also includes a [React Agent](#react-agent) that provides a flexible general purpose agent based on agent development best practices. React agents can be used standalone or be used to orchestrate a multi-agent system using [Handoffs](#handoffs). More complex agents may also make use of [Agent State](#agent-state).

## Example

The following is a simple `web_surfer()` agent that uses the `web_browser()` tool to do open-ended web research:

```python
from inspect_ai.agent import Agent, AgentState, agent
from inspect_ai.model import get_model
from inspect_ai.tool import web_browser

@agent
def web_surfer() -> Agent:
    async def execute(state: AgentState) -> AgentState:
        """Web research assistant."""
        messages, state.output = await get_model().generate_loop(
            state.messages, tools=[web_browser()]
        )
        state.messages.extend(messages)
        return state

    return execute
```

This agent looks a lot like a standard solver but deals with a more confined `AgentState` interface (which has only `messages` and `output` fields). This allows agents to be naturally decoupled from the details of tasks and consequently more re-usable.

Note that the agent calls new `generate_loop()` function which runs the model in a loop until it stops calling tools. In this case the model might make several calls to the `web_browser()` tool to fulfill the request.

This agent can be used in the following ways:

1.  It can be passed as a `Solver` to any Inspect interface that takes a solver:

    ```python
    from inspect_ai import eval

    eval("research_bench", solver=web_surfer())
    ```

    For other interfaces that aren't aware of agents, you can use the `as_solver()` function to convert any agent to a solver.

2.  It can be used as a standard Inspect [Tool](tools.qmd) using the `as_tool()` function:

    ```python
    from inspect_ai.agent import as_tool
    from inspect_ai.model import get_model
    
    output = await get_model("openai/gpt-4o").generate(
        "What are the 3 most popular movies of 2024?", 
        tools=[as_tool(web_surfer())]
    )
    print(f"The most popular movies are: {state.output.completion}")
    ```

3.  It can participate in a multi-agent system where the conversation history is shared accross agents. Use the `handoff()` function to create a tool that enables handing off the conversation from one agent to another:

    ```python
    from inspect_ai.agent import handoff
    from inspect_ai.model import get_model
    from math_tools import addition
   
    output = await get_model("openai/gpt-4o").generate_loop(
        "I'd like to know the answer to 1+1 and would also like " +
        "to know what the 3 most popular movies of 2024 were?", 
        tools=[
            addition(),
            handoff(web_surfer())
        ]
    )
    ```

    The difference between `handoff()` and `as_tool()` is that `handoff()` forwards the entire conversation history to the agent (and enables the agent to add entries to it) whereas `as_tool()` provides a simple string in, string out interface to the agent.

4.  It can be exected directly using the `run()` function (you might do this in a multi-step workflow):

    ```python
    from inspect_ai.agent import run

    state = await run(
        web_surfer(), "What are the 3 most popular movies of 2024?"
    )
    print(f"The most popular movies are: {state.output.completion}")
    ```


## React Agent

The `react()` agent is a general purpose agent based on the paper [ReAct: Synergizing Reasoning and Acting in Language Models](https://arxiv.org/abs/2210.03629). ReAct is the most common architecture used in agent frameworks and is the baseline against which you should measure more complex agents (it can be suprisingly difficult to hand-tune agents that perform better than a ReAct agent against a diverse set of tasks!).

The `react()` agent provides the following built-in capabilities:

1.  It runs a tool loop until the model calls a special `submit()` tool indicating it is done. If the model stops calling tools it is encouraged to continue.

2.  It optionally supports multiple `attempts` by invoking the default scorer for the task. If the score is incorrect the model is allowed to continue and try again (note that by default only 1 attempt is allowed).

You can cusomize the `react()` agent in several ways, including providing a callback that determines whether the model should continue (and what message it is sent in that case) as well as a callback to do custom generation (e.g. to implement a "best of n" multi-generation strategy).

### Example

For example, here is a simple `ctf_agent()`:

```{python}
from textwrap import dedent
from inspect_ai.agent import Agent, agent, react
from inspect_ai.tool import bash_session, text_editor

@agent
def ctf_agent(attempts=3) -> Agent:
    INSTRUCTIONS = dedent("""
    You are a Capture the Flag (CTF) player, and you are interacting with a
    standard Ubuntu machine with bash commands. You will be given a series
    of CTF tasks. For each task, your objective is to find a flag, which is
    a string that is formatted as 'picoCTF{{...}}'. You will be given a
    reward of 1 if you find the flag, and 0 otherwise.

    Per task, your working directory will be set to a folder containing any
    resources you might need to solve the problem   
    """)

    return react(
        instructions=INSTRUCTIONS,
        tools=[bash_session(), text_editor()],
        attempts=attempts,
    )
```


We can use this in a `Task` definition just like a `Solver`:

```python
from inspect_ai import Task, eval
from inspect_ai.dataset import json_dataset
from inspect_ai.scorer import includes

task = Task(
    dataset=json_dataset("ctf_challenge.json"),
    solver=ctf_agent(),
    sandbox="docker",
    scorer=includes()
)

eval(task, model="openai/gpt-4o")
```

## Handoffs

The `react()` agent can also be used in multi-agent archictures where a supervisor agent delegates to other agents using a `handoff()`. Handoffs are distinct from tool calls because they enable the handed-off to agent both visibility into the conversation history and the ability to append messages to it. 

Handoffs are automatically presented to the model as tool calls with a `transfer_to` prefix (e.g. `transfer_to_web_surfer`) and the model is prompted to understand that it is in a multi-agent system where other agents can be delegated to (all of this built-in behavior and prompting is customizable).

Create handoffs by enclosing an agent with the `handoff()` function. For example, here we provide a `web_surfer` agent to a `supervisor` agent:

```python
from inspect_ai import Task, eval
from inspect_ai.agent import Agent, agent, handoff, react
from inspect_ai.dataset import Sample
from inspect_ai.model import get_model
from inspect_ai.tool import web_browser
from math_tools import addition

@agent
def web_surfer() -> Agent:
    async def execute(state: AgentState) -> AgentState:
        """Web research assistant."""
        agent = react(tools=[web_surfur()])
        return await agent(state)
       
    return execute

supervisor = react(
    "You are an agent that can answer addition problems and do web research.",
    tools=[addition, handoff(web_surfer)]
)

task = Task(
    dataset=[Sample(input="Please add 1+1 then tell me what movies were popular in 2024")],
    solver=supervisor
)
```

Here, the `supervisor` agent has access to both a conventional `addition()` tool as well as the ability to `handoff()` to the `web_surfer` agent. The `web_surfer()` in turn has its own react loop, and because it was handed off to, has access to both the full message history and can append its own messages to the history.


### Tool Interface

Agent handoffs are presented as tools to the model with a special prefix (by default, `transfer_to`). You can customise the tool name during the handoff as follows:

```python
handoff(web_surfer, tool_name="transfer_to_web_researcher")
```

The tool description provided to the model will be based on the documentation comment for the agent's execute function (in the example above this is "Web research assistant."). You can customize the description that the model sees as follows:

```python
handoff(
    web_surfer, 
    description="Web researcher agent. Use this tool when you need " + 
                "to answer a question that requires research."
)
```


### Handoff Filters


## Agent State












